IQR_val     <- IQR(x, na.rm = TRUE)
lower_bound <- Q1 - 1.5 * IQR_val
upper_bound <- Q3 + 1.5 * IQR_val
which(x < lower_bound | x > upper_bound)
})
# --- 3. Count outliers per numeric variable ---
outlier_counts <- sapply(outlier_list, length)
print(outlier_counts)
# --- 4. Extract actual outlier values ---
outlier_values <- mapply(
function(col, idx) col[idx],
num_vars,
outlier_list,
SIMPLIFY = FALSE
)
# --- 5. Get all rows in the dataset that contain any outlier ---
outlier_rows <- unique(unlist(outlier_list))
if (length(outlier_rows) > 0) {
outlier_data <- business_model_claims[outlier_rows, ]
print(outlier_data)
} else {
message("No outliers detected.")
}
# --- 6. Draw boxplots for each numeric variable ---
n_cols <- ncol(num_vars)
n_rows <- ceiling(n_cols / 2)
# Open a larger window first (adjust width/height as needed)
windows(width = 12, height = n_rows * 3)  # use quartz() on Mac, X11() on Linux
par(mfrow = c(n_rows, 2),
mar   = c(2, 3, 2, 1),   # reduce margins: bottom, left, top, right
oma   = c(1, 1, 1, 1))   # reduce outer margins
for (col_name in names(num_vars)) {
x_clean <- num_vars[[col_name]][!is.na(num_vars[[col_name]])]
boxplot(
x_clean,
main    = paste("Boxplot of", col_name),
ylab    = col_name,
col     = "lightblue",
outline = TRUE,
cex.main = 0.9,   # slightly smaller title text
cex.axis = 0.8    # slightly smaller axis text
)
}
# --- 7. (Optional) Single combined boxplot ---
# boxplot(num_vars,
#         main = "Boxplots of All Numeric Variables",
#         las  = 2,
#         col  = "lightblue",
#         outline = TRUE)
business_model_claims <- read.csv("C:/Users/hendr/OneDrive/Documents/Rocketeers_SOA/model_data/bussiness_claims_model_data.csv")
str(business_model_claims)
colSums(is.na(business_model_claims))
summary(business_model_claims)
# --- 1. Select numeric columns ---
num_vars <- business_model_claims[, sapply(business_model_claims, is.numeric), drop = FALSE]
# --- 2. Identify outliers using IQR method ---
outlier_list <- lapply(num_vars, function(x) {
Q1          <- quantile(x, 0.25, na.rm = TRUE)
Q3          <- quantile(x, 0.75, na.rm = TRUE)
IQR_val     <- IQR(x, na.rm = TRUE)
lower_bound <- Q1 - 1.5 * IQR_val
upper_bound <- Q3 + 1.5 * IQR_val
which(x < lower_bound | x > upper_bound)
})
# --- 3. Count outliers per numeric variable ---
outlier_counts <- sapply(outlier_list, length)
print(outlier_counts)
# --- 4. Extract actual outlier values ---
outlier_values <- mapply(
function(col, idx) col[idx],
num_vars,
outlier_list,
SIMPLIFY = FALSE
)
# --- 5. Get all rows in the dataset that contain any outlier ---
outlier_rows <- unique(unlist(outlier_list))
if (length(outlier_rows) > 0) {
outlier_data <- business_model_claims[outlier_rows, ]
print(outlier_data)
} else {
message("No outliers detected.")
}
# --- 6. Draw boxplots for each numeric variable ---
n_cols <- ncol(num_vars)
n_rows <- ceiling(n_cols / 2)
# Open a larger window first (adjust width/height as needed)
windows(width = 12, height = n_rows * 3)  # use quartz() on Mac, X11() on Linux
par(mfrow = c(n_rows, 2),
mar   = c(2, 3, 2, 1),   # reduce margins: bottom, left, top, right
oma   = c(1, 1, 1, 1))   # reduce outer margins
for (col_name in names(num_vars)) {
x_clean <- num_vars[[col_name]][!is.na(num_vars[[col_name]])]
boxplot(
x_clean,
main    = paste("Boxplot of", col_name),
ylab    = col_name,
col     = "lightblue",
outline = TRUE,
cex.main = 0.9,   # slightly smaller title text
cex.axis = 0.8    # slightly smaller axis text
)
}
# --- 7. (Optional) Single combined boxplot ---
# boxplot(num_vars,
#         main = "Boxplots of All Numeric Variables",
#         las  = 2,
#         col  = "lightblue",
#         outline = TRUE)
business_model_claims <- read.csv("C:/Users/hendr/OneDrive/Documents/Rocketeers_SOA/model_data/bussiness_claims_model_data.csv")
str(business_model_claims)
colSums(is.na(business_model_claims))
summary(business_model_claims)
# --- 1. Select numeric columns ---
num_vars <- business_model_claims[, sapply(business_model_claims, is.numeric), drop = FALSE]
# --- 2. Identify outliers using IQR method ---
outlier_list <- lapply(num_vars, function(x) {
Q1          <- quantile(x, 0.25, na.rm = TRUE)
Q3          <- quantile(x, 0.75, na.rm = TRUE)
IQR_val     <- IQR(x, na.rm = TRUE)
lower_bound <- Q1 - 1.5 * IQR_val
upper_bound <- Q3 + 1.5 * IQR_val
which(x < lower_bound | x > upper_bound)
})
# --- 3. Count outliers per numeric variable ---
outlier_counts <- sapply(outlier_list, length)
print(outlier_counts)
# --- 4. Extract actual outlier values ---
outlier_values <- mapply(
function(col, idx) col[idx],
num_vars,
outlier_list,
SIMPLIFY = FALSE
)
# --- 5. Get all rows in the dataset that contain any outlier ---
outlier_rows <- unique(unlist(outlier_list))
if (length(outlier_rows) > 0) {
outlier_data <- business_model_claims[outlier_rows, ]
print(outlier_data)
} else {
message("No outliers detected.")
}
# --- 6. Draw boxplots for each numeric variable ---
n_cols <- ncol(num_vars)
n_rows <- ceiling(n_cols / 2)
# Open a larger window first (adjust width/height as needed)
windows(width = 12, height = n_rows * 3)  # use quartz() on Mac, X11() on Linux
par(mfrow = c(n_rows, 2),
mar   = c(2, 3, 2, 1),   # reduce margins: bottom, left, top, right
oma   = c(1, 1, 1, 1))   # reduce outer margins
for (col_name in names(num_vars)) {
x_clean <- num_vars[[col_name]][!is.na(num_vars[[col_name]])]
boxplot(
x_clean,
main    = paste("Boxplot of", col_name),
ylab    = col_name,
col     = "lightblue",
outline = TRUE,
cex.main = 0.9,   # slightly smaller title text
cex.axis = 0.8    # slightly smaller axis text
)
}
7. (Optional) Single combined boxplot ---
business_model_claims <- read.csv("C:/Users/hendr/OneDrive/Documents/Rocketeers_SOA/model_data/bussiness_claims_model_data.csv")
str(business_model_claims)
colSums(is.na(business_model_claims))
summary(business_model_claims)
# --- 1. Select numeric columns ---
num_vars <- business_model_claims[, sapply(business_model_claims, is.numeric), drop = FALSE]
# --- 2. Identify outliers using IQR method ---
outlier_list <- lapply(num_vars, function(x) {
Q1          <- quantile(x, 0.25, na.rm = TRUE)
Q3          <- quantile(x, 0.75, na.rm = TRUE)
IQR_val     <- IQR(x, na.rm = TRUE)
lower_bound <- Q1 - 1.5 * IQR_val
upper_bound <- Q3 + 1.5 * IQR_val
which(x < lower_bound | x > upper_bound)
})
# --- 3. Count outliers per numeric variable ---
outlier_counts <- sapply(outlier_list, length)
print(outlier_counts)
# --- 4. Extract actual outlier values ---
outlier_values <- mapply(
function(col, idx) col[idx],
num_vars,
outlier_list,
SIMPLIFY = FALSE
)
# --- 5. Get all rows in the dataset that contain any outlier ---
outlier_rows <- unique(unlist(outlier_list))
if (length(outlier_rows) > 0) {
outlier_data <- business_model_claims[outlier_rows, ]
print(outlier_data)
} else {
message("No outliers detected.")
}
# --- 6. Draw boxplots for each numeric variable ---
n_cols <- ncol(num_vars)
n_rows <- ceiling(n_cols / 2)
# Open a larger window first (adjust width/height as needed)
windows(width = 12, height = n_rows * 3)  # use quartz() on Mac, X11() on Linux
par(mfrow = c(n_rows, 2),
mar   = c(2, 3, 2, 1),   # reduce margins: bottom, left, top, right
oma   = c(1, 1, 1, 1))   # reduce outer margins
for (col_name in names(num_vars)) {
x_clean <- num_vars[[col_name]][!is.na(num_vars[[col_name]])]
boxplot(
x_clean,
main    = paste("Boxplot of", col_name),
ylab    = col_name,
col     = "lightblue",
outline = TRUE,
cex.main = 0.9,   # slightly smaller title text
cex.axis = 0.8    # slightly smaller axis text
)
}
#7. (Optional) Single combined boxplot ---
boxplot(num_vars,
main = "Boxplots of All Numeric Variables",
las  = 2,
col  = "lightblue",
outline = TRUE)
# =============================================================================
# PURE PREMIUM MODEL — Business Claims
# =============================================================================
# Actuarial Approach : Frequency × Severity (two-part GLM)
#   • Frequency  : Poisson GLM  — expected claims per unit exposure
#   • Severity   : Gamma GLM    — expected claim amount given a claim occurred
#   • Pure Premium = Frequency × Severity
#
# A direct Tweedie GLM is also fitted as a cross-check.
#
# Variables
#   Response   : claim_count (frequency), claim_amount (severity)
#   Offset     : log(exposure)  — normalises for differing exposure periods
#   Categorical: solar_system, energy_backup_score, safety_compliance,
#                maintenance_freq
#   Continuous : production_load, supply_chain_index, avg_crew_exp
# =============================================================================
# ── 0. Dependencies ───────────────────────────────────────────────────────────
required_packages <- c("tidyverse", "tweedie", "statmod", "caret",
"gridExtra", "scales", "knitr")
for (pkg in required_packages) {
if (!requireNamespace(pkg, quietly = TRUE)) {
install.packages(pkg, repos = "https://cloud.r-project.org")
}
library(pkg, character.only = TRUE)
}
set.seed(42)
# ── 1. Load & Prepare Data ────────────────────────────────────────────────────
cat("\n========== 1. LOADING DATA ==========\n")
df <- read.csv("C:/Users/hendr/OneDrive/Documents/Rocketeers_SOA/model_data/bussiness_claims_model_data.csv", stringsAsFactors = FALSE)
cat(sprintf("Loaded %s rows × %s columns\n", nrow(df), ncol(df)))
# --- Type conversions ---
df <- df %>%
mutate(
# Categorical factors (ordered where applicable)
solar_system        = factor(solar_system,
levels = c("Epsilon", "Helionis Cluster", "Zeta")),
energy_backup_score = factor(energy_backup_score, levels = 1:5, ordered = TRUE),
safety_compliance   = factor(safety_compliance,   levels = 1:5, ordered = TRUE),
maintenance_freq    = factor(maintenance_freq,    levels = 0:6, ordered = TRUE),
# Derived response
pure_premium = claim_amount / exposure,   # actual PP for diagnostics
has_claim    = as.integer(claim_count > 0)
)
cat("\nClaim summary:\n")
cat(sprintf("  Policies          : %s\n", nrow(df)))
cat(sprintf("  Policies w/ claims: %s (%.1f%%)\n",
sum(df$claim_count > 0),
100 * mean(df$claim_count > 0)))
cat(sprintf("  Total exposure    : %.0f\n", sum(df$exposure)))
cat(sprintf("  Total claim amt   : R%s\n",
format(sum(df$claim_amount), big.mark = ",")))
cat(sprintf("  Avg pure premium  : R%s\n",
format(round(mean(df$pure_premium)), big.mark = ",")))
# ── 2. Train / Test Split (80/20) ─────────────────────────────────────────────
cat("\n========== 2. TRAIN / TEST SPLIT ==========\n")
train_idx <- createDataPartition(df$has_claim, p = 0.8, list = FALSE)
train     <- df[ train_idx, ]
test      <- df[-train_idx, ]
cat(sprintf("Train: %s rows | Test: %s rows\n", nrow(train), nrow(test)))
# ── 3. FREQUENCY MODEL — Poisson GLM ─────────────────────────────────────────
cat("\n========== 3. FREQUENCY MODEL (Poisson GLM) ==========\n")
freq_model <- glm(
claim_count ~
solar_system +
production_load +
energy_backup_score +
supply_chain_index +
avg_crew_exp +
maintenance_freq +
safety_compliance +
offset(log(exposure)),          # <— critical: normalise for exposure
family  = poisson(link = "log"),
data    = train
)
cat("\nFrequency Model Summary:\n")
print(summary(freq_model))
# Overdispersion check
dispersion_ratio <- sum(residuals(freq_model, type = "pearson")^2) / freq_model$df.residual
cat(sprintf("\nDispersion ratio: %.3f  (>1 suggests overdispersion — consider quasi-Poisson)\n",
dispersion_ratio))
# If overdispersed, refit with quasi-Poisson
if (dispersion_ratio > 1.5) {
cat("Refitting with quasi-Poisson to account for overdispersion...\n")
freq_model <- glm(
claim_count ~
solar_system +
production_load +
energy_backup_score +
supply_chain_index +
avg_crew_exp +
maintenance_freq +
safety_compliance +
offset(log(exposure)),
family = quasipoisson(link = "log"),
data   = train
)
}
# ── 4. SEVERITY MODEL — Gamma GLM (claims-only subset) ───────────────────────
cat("\n========== 4. SEVERITY MODEL (Gamma GLM) ==========\n")
train_claims <- train %>% filter(claim_count > 0)
cat(sprintf("Severity training records: %s\n", nrow(train_claims)))
sev_model <- glm(
(claim_amount / claim_count) ~    # average cost per claim
solar_system +
production_load +
energy_backup_score +
supply_chain_index +
avg_crew_exp +
maintenance_freq +
safety_compliance,
family  = Gamma(link = "log"),
weights = claim_count,            # weight by number of claims
data    = train_claims
)
# =============================================================================
# PURE PREMIUM MODEL — Business Claims
# =============================================================================
# Actuarial Approach : Frequency × Severity (two-part GLM)
#   • Frequency  : Poisson GLM  — expected claims per unit exposure
#   • Severity   : Gamma GLM    — expected claim amount given a claim occurred
#   • Pure Premium = Frequency × Severity
#
# A direct Tweedie GLM is also fitted as a cross-check.
#
# Variables
#   Response   : claim_count (frequency), claim_amount (severity)
#   Offset     : log(exposure)  — normalises for differing exposure periods
#   Categorical: solar_system, energy_backup_score, safety_compliance,
#                maintenance_freq
#   Continuous : production_load, supply_chain_index, avg_crew_exp
# =============================================================================
# ── 0. Dependencies ───────────────────────────────────────────────────────────
required_packages <- c("tidyverse", "tweedie", "statmod", "caret",
"gridExtra", "scales", "knitr")
for (pkg in required_packages) {
if (!requireNamespace(pkg, quietly = TRUE)) {
install.packages(pkg, repos = "https://cloud.r-project.org")
}
library(pkg, character.only = TRUE)
}
set.seed(42)
# ── 1. Load & Prepare Data ────────────────────────────────────────────────────
cat("\n========== 1. LOADING DATA ==========\n")
df <- read.csv("bussiness_claims_model_data.csv", stringsAsFactors = FALSE)
# =============================================================================
# PURE PREMIUM MODEL — Business Claims
# =============================================================================
# Actuarial Approach : Frequency × Severity (two-part GLM)
#   • Frequency  : Poisson GLM  — expected claims per unit exposure
#   • Severity   : Gamma GLM    — expected claim amount given a claim occurred
#   • Pure Premium = Frequency × Severity
#
# A direct Tweedie GLM is also fitted as a cross-check.
#
# Variables
#   Response   : claim_count (frequency), claim_amount (severity)
#   Offset     : log(exposure)  — normalises for differing exposure periods
#   Categorical: solar_system, energy_backup_score, safety_compliance,
#                maintenance_freq
#   Continuous : production_load, supply_chain_index, avg_crew_exp
# =============================================================================
# ── 0. Dependencies ───────────────────────────────────────────────────────────
required_packages <- c("tidyverse", "tweedie", "statmod", "caret",
"gridExtra", "scales", "knitr")
for (pkg in required_packages) {
if (!requireNamespace(pkg, quietly = TRUE)) {
install.packages(pkg, repos = "https://cloud.r-project.org")
}
library(pkg, character.only = TRUE)
}
set.seed(42)
# ── 1. Load & Prepare Data ────────────────────────────────────────────────────
cat("\n========== 1. LOADING DATA ==========\n")
df <- read.csv("C:\\Users\\hendr\\OneDrive\\Documents\\Rocketeers_SOA\\model_data\\bussiness_claims_model_data.csv", stringsAsFactors = FALSE)
cat(sprintf("Loaded %s rows × %s columns\n", nrow(df), ncol(df)))
# --- Type conversions ---
df <- df %>%
mutate(
# Categorical factors (ordered where applicable)
solar_system        = factor(solar_system,
levels = c("Epsilon", "Helionis Cluster", "Zeta")),
energy_backup_score = factor(energy_backup_score, levels = 1:5, ordered = TRUE),
safety_compliance   = factor(safety_compliance,   levels = 1:5, ordered = TRUE),
maintenance_freq    = factor(maintenance_freq,    levels = 0:6, ordered = TRUE),
# Derived response
pure_premium = claim_amount / exposure,   # actual PP for diagnostics
has_claim    = as.integer(claim_count > 0)
)
cat("\nClaim summary:\n")
cat(sprintf("  Policies          : %s\n", nrow(df)))
cat(sprintf("  Policies w/ claims: %s (%.1f%%)\n",
sum(df$claim_count > 0),
100 * mean(df$claim_count > 0)))
cat(sprintf("  Total exposure    : %.0f\n", sum(df$exposure)))
cat(sprintf("  Total claim amt   : R%s\n",
format(sum(df$claim_amount), big.mark = ",")))
cat(sprintf("  Avg pure premium  : R%s\n",
format(round(mean(df$pure_premium)), big.mark = ",")))
# ── 2. Train / Test Split (80/20) ─────────────────────────────────────────────
cat("\n========== 2. TRAIN / TEST SPLIT ==========\n")
train_idx <- createDataPartition(df$has_claim, p = 0.8, list = FALSE)
train     <- df[ train_idx, ]
test      <- df[-train_idx, ]
cat(sprintf("Train: %s rows | Test: %s rows\n", nrow(train), nrow(test)))
# ── 3. FREQUENCY MODEL — Poisson GLM ─────────────────────────────────────────
cat("\n========== 3. FREQUENCY MODEL (Poisson GLM) ==========\n")
freq_model <- glm(
claim_count ~
solar_system +
production_load +
energy_backup_score +
supply_chain_index +
avg_crew_exp +
maintenance_freq +
safety_compliance +
offset(log(exposure)),          # <— critical: normalise for exposure
family  = poisson(link = "log"),
data    = train
)
cat("\nFrequency Model Summary:\n")
print(summary(freq_model))
# Overdispersion check
dispersion_ratio <- sum(residuals(freq_model, type = "pearson")^2) / freq_model$df.residual
cat(sprintf("\nDispersion ratio: %.3f  (>1 suggests overdispersion — consider quasi-Poisson)\n",
dispersion_ratio))
# If overdispersed, refit with quasi-Poisson
if (dispersion_ratio > 1.5) {
cat("Refitting with quasi-Poisson to account for overdispersion...\n")
freq_model <- glm(
claim_count ~
solar_system +
production_load +
energy_backup_score +
supply_chain_index +
avg_crew_exp +
maintenance_freq +
safety_compliance +
offset(log(exposure)),
family = quasipoisson(link = "log"),
data   = train
)
}
# ── 4. SEVERITY MODEL — Gamma GLM (claims-only subset) ───────────────────────
cat("\n========== 4. SEVERITY MODEL (Gamma GLM) ==========\n")
# Gamma GLM requires strictly positive response values.
# Exclude the rare records where claim_count > 0 but claim_amount = 0
# (data quality issue — a claim event was recorded but no amount was captured).
train_claims_raw <- train %>% filter(claim_count > 0)
train_claims     <- train_claims_raw %>% filter(claim_amount > 0)
n_zero_amt <- nrow(train_claims_raw) - nrow(train_claims)
if (n_zero_amt > 0) {
cat(sprintf("  Note: %s record(s) had claim_count > 0 but claim_amount = 0 — excluded from severity model.\n",
n_zero_amt))
}
cat(sprintf("Severity training records: %s\n", nrow(train_claims)))
sev_model <- glm(
(claim_amount / claim_count) ~    # average cost per claim
solar_system +
production_load +
energy_backup_score +
supply_chain_index +
avg_crew_exp +
maintenance_freq +
safety_compliance,
family  = Gamma(link = "log"),
weights = claim_count,            # weight by number of claims
data    = train_claims
)
cat("\nSeverity Model Summary:\n")
print(summary(sev_model))
# ── 5. TWEEDIE GLM (Direct Pure Premium — cross-check) ───────────────────────
cat("\n========== 5. TWEEDIE GLM (Direct Pure Premium) ==========\n")
# Estimate optimal Tweedie power (p) — compound Poisson range: 1 < p < 2
library(tweedie)
library(statmod)
xi_profile <- tweedie.profile(
pure_premium ~
solar_system +
production_load +
energy_backup_score +
supply_chain_index +
avg_crew_exp +
maintenance_freq +
safety_compliance,
p.vec   = seq(1.2, 1.9, by = 0.1),
link    = "log",
weights = train$exposure,
data    = train,
do.plot = FALSE
)
